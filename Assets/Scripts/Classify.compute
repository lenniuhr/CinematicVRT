#pragma kernel Classify
#pragma kernel Blur

#include "Assets/Shaders/Library/Classification.hlsl"
#include "Assets/Shaders/Library/Common.hlsl"

Texture3D<half> _DensityTex3D;
Texture3D<half3> _GradientTex3D;

RWTexture3D<half4> _Result;
Texture3D<half4> _PrevResult;

float _RangeMin;
float _RangeMax;

float _FadeOut;
float4 _Dimension;

float4 GetGradientLimits()
{
    float4 gradientLimits = 0;
    gradientLimits.r = _DensityClasses[0].gradientLimit;
    gradientLimits.g = _DensityClasses[1].gradientLimit;
    gradientLimits.b = _DensityClasses[2].gradientLimit;
    return gradientLimits;
}

[numthreads(8, 8, 8)]
void Classify(uint3 id : SV_DispatchThreadID)
{
    float3 uv = id / float3(512, 512, 460);
    int index = (512 * 512 * id.z + 512 * id.y + id.x);
    
    float density = _DensityTex3D[id].r;
    density = clamp(density, _RangeMin, _RangeMax);
    
    float3 gradient = _GradientTex3D[id].xyz * 2 - 1;
    
    float value = 0;
    
    float4 gradientLimits = GetGradientLimits();
    float4 w = InverseLerpVector4(gradientLimits, 0, length(gradient));
    
    float4 color = 0;
    color.r = GetClassDensity(density, 0) * w.r;
    color.g = GetClassDensity(density, 1) * w.g;
    color.b = GetClassDensity(density, 2) * w.b;
    
    // Fade out factor
    float x01 = abs((id.x / _Dimension.x) * 2 - 1);
    float y01 = abs((id.y / _Dimension.y) * 2 - 1);
    float fadeOut = (1 - smoothstep(_FadeOut, _FadeOut + 0.01, length(float2(x01, y01))));
    
    _Result[id] = color * fadeOut;
}

float Gauss(float sigma, int x, int y, int z)
{
    return exp(-(x * x + y * y + z * z) / (2 * sigma * sigma * sigma));
}

int _KernelRadius;
float _Sigma;

float4 GaussianBlur(int3 id)
{
    int kernelRadius = _KernelRadius;
    float sigma = _Sigma;
    float sigmaR = 0.5;
    
    float4 color = 0;
    float totalWeight = 0;
    
    for (int x = -kernelRadius; x <= kernelRadius; x++)
    {
        for (int y = -kernelRadius; y <= kernelRadius; y++)
        {
            for (int z = -kernelRadius; z <= kernelRadius; z++)
            {
                int3 neighborId = id + int3(x, y, z);
                float4 value = _PrevResult[neighborId];
            
                float weight = Gauss(sigma, x, y, z);
            
                color += weight * value;
                totalWeight += weight;
            }
        }
    }

    return color / totalWeight;
}

[numthreads(8, 8, 8)]
void Blur(uint3 id : SV_DispatchThreadID)
{
    float density = _DensityTex3D[id];
    density = clamp(density, _RangeMin, _RangeMax);
    
    float3 gradient = _GradientTex3D[id].xyz * 2 - 1;
    
    int bufferIndex = 512 * id.y + id.x;
    
    float4 gradientLimits = GetGradientLimits();
    float4 w = InverseLerpVector4(gradientLimits, 0, length(gradient));
    
    float4 color = 0;
    color.r = GetClassDensity(density, 0) * w.r;
    color.g = GetClassDensity(density, 1) * w.g;
    color.b = GetClassDensity(density, 2) * w.b;
    
    // Fade out factor
    float x01 = abs((id.x / _Dimension.x) * 2 - 1);
    float y01 = abs((id.y / _Dimension.y) * 2 - 1);
    float fadeOut = (1 - smoothstep(_FadeOut, _FadeOut + 0.01, length(float2(x01, y01))));
    color *= fadeOut;
    
    float4 neighborGrayscale = 0;
    
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            for (int z = -1; z <= 1; z++)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;
            
                int3 neighborId = id + int3(x, y, z);
                neighborGrayscale += _PrevResult[neighborId];
            }
        }
    }
    float4 gauss = GaussianBlur(id);
    _Result[id] = lerp(gauss, color, w);
}

