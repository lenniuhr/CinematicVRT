#pragma kernel Classify
#pragma kernel Dilate

#include "Assets/Shaders/Library/Classification.hlsl"
#include "Assets/Shaders/Library/Common.hlsl"

Texture3D<half> _DensityTex3D;
Texture3D<half3> _GradientTex3D;

RWTexture3D<half4> _Result;
Texture3D<half4> _PrevResult;

float GetGradient(float density)
{
    if (InDensityRange(density, 0))
    {
        return _DensityClasses[0].gradientLimit;
    }
    else if (InDensityRangeMinMax(GetMax(0), GetMin(1), density))
    {
        return lerp(_DensityClasses[0].gradientLimit, _DensityClasses[1].gradientLimit, InverseLerp(GetMax(0), GetMin(1), density));
    }
    else if (InDensityRange(density, 1))
    {
        return _DensityClasses[1].gradientLimit;
    }
    else if (InDensityRangeMinMax(GetMax(1), GetMin(2), density))
    {
        return lerp(_DensityClasses[1].gradientLimit, _DensityClasses[2].gradientLimit, InverseLerp(GetMax(1), GetMin(2), density));
    }
    else if (InDensityRange(density, 2))
    {
        return _DensityClasses[2].gradientLimit;
    }
    return 0.06;
}

float GetGrayscale(float density)
{
    if (InDensityRange(density, 0))
    {
        return 0.1;
    }
    else if (InDensityRangeMinMax(GetMax(0), GetMin(1), density))
    {
        return 0;
        return lerp(0.1, 0.4, InverseLerp(GetMax(0), GetMin(1), density));
    }
    else if (InDensityRange(density, 1))
    {
        return 0.4;
    }
    else if (InDensityRangeMinMax(GetMax(1), GetMin(2), density))
    {
        return 0;
        return lerp(0.4, 1, InverseLerp(GetMax(1), GetMin(2), density));
    }
    else if (InDensityRange(density, 2))
    {
        return 1;
    }
    return 0;
}

float4 GetGradientLimits()
{
    float4 gradientLimits = 0;
    gradientLimits.r = _DensityClasses[0].gradientLimit;
    gradientLimits.g = _DensityClasses[1].gradientLimit;
    gradientLimits.b = _DensityClasses[2].gradientLimit;
    return gradientLimits;
}

[numthreads(8, 8, 8)]
void Classify(uint3 id : SV_DispatchThreadID)
{
    float3 uv = id / float3(512, 512, 460);
    int index = (512 * 512 * id.z + 512 * id.y + id.x);
    
    float density = _DensityTex3D[id].r;
    float3 gradient = _GradientTex3D[id].xyz * 2 - 1;
    
    float value = 0;
    
    _Result[id] = GetGrayscale(density);
    
    float4 gradientLimits = GetGradientLimits();
    float4 w = InverseLerpVector4(gradientLimits, 0, length(gradient));
    
    float4 color = 0;
    color.r = GetClassDensity(density, 0) * w.r;
    color.g = GetClassDensity(density, 1) * w.g;
    color.b = GetClassDensity(density, 2) * w.b;
    _Result[id] = color;
}

float Gauss(float sigma, int x, int y, int z)
{
    return exp(-(x * x + y * y + z * z) / (2 * sigma * sigma * sigma));
}

int _KernelRadius;
float _Sigma;

float4 GaussianBlur(int3 id)
{
    int kernelRadius = _KernelRadius;
    float sigma = _Sigma;
    float sigmaR = 0.5;
    
    float4 color = 0;
    float totalWeight = 0;
    
    for (int x = -kernelRadius; x <= kernelRadius; x++)
    {
        for (int y = -kernelRadius; y <= kernelRadius; y++)
        {
            for (int z = -kernelRadius; z <= kernelRadius; z++)
            {
                int3 neighborId = id + int3(x, y, z);
                float4 value = _PrevResult[neighborId];
            
                float weight = Gauss(sigma, x, y, z);
            
                color += weight * value;
                totalWeight += weight;
            }
        }
    }

    return color / totalWeight;
}

[numthreads(8, 8, 8)]
void Dilate(uint3 id : SV_DispatchThreadID)
{
    float density = _DensityTex3D[id];
    float3 gradient = _GradientTex3D[id].xyz * 2 - 1;
    
    int bufferIndex = 512 * id.y + id.x;
    
    float4 gradientLimits = GetGradientLimits();
    float4 w = InverseLerpVector4(gradientLimits, 0, length(gradient));
    
    float4 color = 0;
    color.r = GetClassDensity(density, 0) * w.r;
    color.g = GetClassDensity(density, 1) * w.g;
    color.b = GetClassDensity(density, 2) * w.b;
    
    float4 ownGrayscale = color;
    
    float4 neighborGrayscale = 0;
    
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            for (int z = -1; z <= 1; z++)
            {
                if (x == 0 && y == 0 && z == 0)
                    continue;
            
                int3 neighborId = id + int3(x, y, z);
                neighborGrayscale += _PrevResult[neighborId];
            }
        }
    }
    float4 gauss = GaussianBlur(id);
    _Result[id] = lerp(gauss, color, w);
}

