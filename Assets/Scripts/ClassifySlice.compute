#pragma kernel Classify
#pragma kernel Blur
#pragma kernel CreateImage

#include "Assets/Shaders/Library/Classification.hlsl"
#include "Assets/Shaders/Library/Common.hlsl"


Texture3D<half> _DensityTex;
Texture3D<half3> _GradientTex;

float _RangeMin;
float _RangeMax;

RWTexture2D<half4> _Result;
Texture2D<half4> _PrevFrame;

int _Slice;
bool _DisplayGrayscale;
float _FadeOut;
float4 _Dimension;

float GetDensity01(int3 id)
{
    float density = _DensityTex[id];
    return (density - _RangeMin) / (_RangeMax - _RangeMin);
}

[numthreads(8, 8, 1)]
void Classify(uint3 id : SV_DispatchThreadID)
{
    uint3 index = uint3(id.xy, _Slice);
    
    half density = _DensityTex[index];
    density = clamp(density, _RangeMin, _RangeMax);
    
    half3 gradient = _GradientTex[index].xyz * 2 - 1;
    
    half4 color = 0;
    
    float4 gradientLimit = 0;
    gradientLimit.r = _DensityClasses[0].gradientLimit;
    gradientLimit.g = _DensityClasses[1].gradientLimit;
    gradientLimit.b = _DensityClasses[2].gradientLimit;
    
    float4 w = InverseLerpVector4(gradientLimit, 0, length(gradient));
    
    color.r = GetClassDensity(density, 0) * w.r;
    color.g = GetClassDensity(density, 1) * w.g;
    color.b = GetClassDensity(density, 2) * w.b;
    
    // Fade out factor
    float x01 = abs((id.x / _Dimension.x) * 2 - 1);
    float y01 = abs((id.y / _Dimension.y) * 2 - 1);
    float fadeOut = (1 - smoothstep(_FadeOut, _FadeOut + 0.01, length(float2(x01, y01))));
    
    _Result[id.xy] = color * fadeOut;
}

float Gauss(float sigma, int x, int y)
{
    return exp(-(x * x + y * y) / (2 * sigma * sigma));
}

int _KernelRadius;
float _Sigma;

float4 GaussianBlur(int3 id)
{
    int kernelRadius = _KernelRadius;
    float sigma = _Sigma;
    float sigmaR = 0.5;
    
    float4 color = 0;
    float totalWeight = 0;
    
    for (int x = -kernelRadius; x <= kernelRadius; x++)
    {
        for (int y = -kernelRadius; y <= kernelRadius; y++)
        {
            int2 neighborId = id.xy + int2(x, y);
            float4 value = _PrevFrame[neighborId];
            
            float weight = Gauss(sigma, x, y);
            
            color += weight * value;
            totalWeight += weight;
        }
    }

    return color / totalWeight;
}

Texture2D<half> PrevFrame;

[numthreads(8, 8, 1)]
void Blur(uint3 id : SV_DispatchThreadID)
{
    uint3 index = uint3(id.xy, _Slice);
    half density = _DensityTex[index];
    density = clamp(density, _RangeMin, _RangeMax);
    
    half3 gradient = _GradientTex[index].xyz * 2 - 1;
    
    int bufferIndex = 512 * id.y + id.x;
    
    float4 neighborGrayscale = 0;
   
    float4 gradientLimit = 0;
    
    gradientLimit.r = _DensityClasses[0].gradientLimit;
    gradientLimit.g = _DensityClasses[1].gradientLimit;
    gradientLimit.b = _DensityClasses[2].gradientLimit;

    float4 w = InverseLerpVector4(gradientLimit, 0, length(gradient));
    
    float sigma = 1;
    
    float4 color = 0;
    float totalWeight = 0;
    
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            //if (x == 0 && y == 0)
            //    continue;
            
            int2 neighborId = id.xy + int2(x, y);
            neighborGrayscale += _PrevFrame[neighborId];
            
            float4 value = _PrevFrame[neighborId];
            float weight = Gauss(sigma, x, y);
            
            color += weight * value;
            totalWeight += weight;
        }
    }
    
    
    float4 ownGrayscale = 0;
    ownGrayscale.r = GetClassDensity(density, 0) * w.r;
    ownGrayscale.g = GetClassDensity(density, 1) * w.g;
    ownGrayscale.b = GetClassDensity(density, 2) * w.b;
    
    // Fade out factor
    float x01 = abs((id.x / _Dimension.x) * 2 - 1);
    float y01 = abs((id.y / _Dimension.y) * 2 - 1);
    float fadeOut = (1 - smoothstep(_FadeOut, _FadeOut + 0.01, length(float2(x01, y01))));
    ownGrayscale *= fadeOut;
    
    float4 gauss = GaussianBlur(id);
    _Result[id.xy] = lerp(gauss, ownGrayscale, w);
}
    

RWTexture2D<half4> _Image;

[numthreads(8, 8, 1)]
void CreateImage(uint3 id : SV_DispatchThreadID)
{
    uint3 index = uint3(id.xy, _Slice);
    half density = GetDensity01(index);
    half3 gradient = _GradientTex[index].xyz * 2 - 1;
    
    float width = 0.5;
    
    float distance01 = abs(256.0 - id.x) / 256.0;
    
    float value;
    if (distance01 < width)
    {
        value = 1;
    }
    else
    {
        distance01 = (distance01 - width) / (1 - width);
        value = cos(distance01 * 3.1415) * 0.5 + 0.5;
    }
    
    
    //_Result[id.xy] = half4(gradient, 1);
    
    if (_DisplayGrayscale)
    {
        _Result[id.xy] = density;
        //_Result[id.xy] = 1 - length(gradient);
    }

}

